/*
 * FILE:	dtrace_util.c
 * DESCRIPTION:	Dynamic Tracing: Architecture utility functions
 *
 * Copyright (C) 2010-2014 Oracle Corporation
 */

#include <linux/dtrace_cpu.h>
#include <linux/kdebug.h>
#include <linux/module.h>
#include <linux/notifier.h>
#include <linux/slab.h>
#include <asm/insn.h>
#include <asm/ptrace.h>
#include <asm/text-patching.h>
#include <asm/dtrace_arch.h>
#include <asm/dtrace_util.h>

/*
 * Move the instruction pointer forward to the next instruction, effectiely
 * skipping the current one.
 */
void dtrace_skip_instruction(struct pt_regs *regs) {
	struct insn		insn;

	kernel_insn_init(&insn, (void *)regs->ip, MAX_INSN_SIZE);
	insn_get_length(&insn);

	regs->ip += insn.length;
}

void dtrace_handle_badaddr(struct pt_regs *regs) {
	unsigned long	addr = read_cr2();

	DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
	this_cpu_core->cpuc_dtrace_illval = addr;

	dtrace_skip_instruction(regs);
}

typedef struct dtrace_invop_hdlr {
	uint8_t				(*dtih_func)(struct pt_regs *);
	struct dtrace_invop_hdlr	*dtih_next;
} dtrace_invop_hdlr_t;

static dtrace_invop_hdlr_t	*dtrace_invop_hdlrs;

#if 1
# define INVOP_TRAP_INSTR	0xf0
#else
# define INVOP_TRAP_INSTR	0xcc
#endif

/*
 * Trap notification handler.
 */
int dtrace_die_notifier(struct notifier_block *nb, unsigned long val,
			void *args)
{
	struct die_args		*dargs = args;

	switch (val) {
	case DIE_PAGE_FAULT: {
		if (!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))
			return NOTIFY_DONE;

		dtrace_handle_badaddr(dargs->regs);

		return NOTIFY_OK | NOTIFY_STOP_MASK;
	}
	case DIE_GPF: {
		/*
		 * This gets messy...  For one, some versions of Xen deliver
		 * the invalid opcode generated by the LOCK prefix (0xf0) as a
		 * GP fault rather than a UD fault.  So, we need to figure out
		 * whether the GP we're processing here is one of those
		 * misreported faults.
		 *
		 * But, it is possible that the instruction that caused the
		 * fault (0xf0) gets overwritten by a different CPU with the
		 * original valid opcode before we get to look at it here,
		 * which makes it kind of hard to recognize.
		 *
		 * So...  we're going to assume that a GP fault that gets
		 * triggered for the LOCK prefix opcode (0xf0) *or* for an
		 * opcode that can get overwritten with the LOCK prefix for
		 * probing is actually a UD fault.
		 *
		 * If we are wrong, the handlers will simply see a fault that
		 * isn't theirs, and return without consuming it.  And in that
		 * case, the kernel will report a UD fault that may have been
		 * a real GP fault...  Sorry.
		 */
		asm_instr_t	opc = *(asm_instr_t *)dargs->regs->ip;

		if (opc != 0xf0 && opc != 0x55 && opc != 0xc3) {
			if (!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))
				return NOTIFY_DONE;

			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);

			dargs->regs->ip += 1;

			return NOTIFY_OK | NOTIFY_STOP_MASK;
		}

		/*
		 * ... and instead treat them as the SDT probe point traps that
		 * they are.
		 */
		dargs->trapnr = 6;
	}
	case DIE_TRAP: {
		dtrace_invop_hdlr_t	*hdlr;
		int			rval = 0;

		if (dargs->trapnr != 6)
			return NOTIFY_DONE;

		for (hdlr = dtrace_invop_hdlrs; hdlr != NULL;
		     hdlr = hdlr->dtih_next) {
			if ((rval = hdlr->dtih_func(dargs->regs)) != 0)
				break;
		}

		switch (rval) {
		case DTRACE_INVOP_NOPS:
			/*
			 * SDT probe points are encoded as either:
			 *   - a 1-byte NOP followed by a multi-byte NOP
			 *   - a multi-byte code sequence (to set AX to 0),
			 *     followed by a multi-byte NOP
			 * In both cases, the total length of the probe point
			 * instruction is ASM_CALL_SITE bytes, so we can safely
			 * skip that number of bytes here.
			 */
			dargs->regs->ip += ASM_CALL_SIZE;
			return NOTIFY_OK | NOTIFY_STOP_MASK;
		case DTRACE_INVOP_MOV_RSP_RBP:
		case DTRACE_INVOP_NOP:
		case DTRACE_INVOP_PUSH_BP:
		case DTRACE_INVOP_RET:
			return notifier_from_errno(-rval);
		default:
			/*
			 * This must not have been a trap triggered from a
			 * probe point.  Re-adjust the instruction pointer
			 * and let someone else deal with it...
			 */
			dargs->regs->ip++;
		}

		return NOTIFY_DONE;
	}
	case DIE_INT3: {
		dtrace_invop_hdlr_t	*hdlr;
		int			rval = 0;

		/*
		 * Let's assume that this is a DTrace probe firing, so we need
		 * to adjust the IP (to be consistent with #UD processing) so
		 * that it reflects the address of the #BP rather than the
		 * following intruction.
		 *
		 * If it turns out that this was not DTrace related, we'll have
		 * to reverse this adjustment.
		 */
		dargs->regs->ip--;
		for (hdlr = dtrace_invop_hdlrs; hdlr != NULL;
		     hdlr = hdlr->dtih_next) {
			rval = hdlr->dtih_func(dargs->regs);
			if (rval != 0)
				break;
		}

		switch (rval) {
		case DTRACE_INVOP_NOPS:
			/*
			 * SDT probe points are encoded as either:
			 *   - a 1-byte NOP followed by a multi-byte NOP
			 *   - a multi-byte code sequence (to set AX to 0),
			 *     followed by a multi-byte NOP
			 * In both cases, the total length of the probe point
			 * instruction is ASM_CALL_SITE bytes, so we can safely
			 * skip that number of bytes here.
			 */
			dargs->regs->ip += ASM_CALL_SIZE;
			return NOTIFY_OK | NOTIFY_STOP_MASK;
		case DTRACE_INVOP_MOV_RSP_RBP:
		case DTRACE_INVOP_NOP:
		case DTRACE_INVOP_PUSH_BP:
		case DTRACE_INVOP_RET:
			return notifier_from_errno(-rval);
		default:
			/*
			 * This must not have been a trap triggered from a
			 * probe point.  Re-adjust the instruction pointer
			 * and let someone else deal with it...
			 */
			dargs->regs->ip++;
		}
	}
	default:
		return NOTIFY_DONE;
	}
}

/*
 * Add an INVOP trap handler.
 */
int dtrace_invop_add(uint8_t (*func)(struct pt_regs *))
{
	dtrace_invop_hdlr_t	*hdlr;

	hdlr = kmalloc(sizeof(dtrace_invop_hdlr_t), GFP_KERNEL);
	if (hdlr == NULL) {
		pr_warn("Failed to add invop handler: out of memory\n");
		return -ENOMEM;
	}

	hdlr->dtih_func = func;
	hdlr->dtih_next = dtrace_invop_hdlrs;
	dtrace_invop_hdlrs = hdlr;

	return 0;
}
EXPORT_SYMBOL(dtrace_invop_add);

/*
 * Remove an INVOP trap handler.
 */
void dtrace_invop_remove(uint8_t (*func)(struct pt_regs *))
{
	dtrace_invop_hdlr_t	*hdlr = dtrace_invop_hdlrs, *prev = NULL;

	for (;;) {
		if (hdlr == NULL)
			return;

		if (hdlr->dtih_func == func)
			break;

		prev = hdlr;
		hdlr = hdlr->dtih_next;
	}

	if (prev == NULL) {
		dtrace_invop_hdlrs = hdlr->dtih_next;
	} else
		prev->dtih_next = hdlr->dtih_next;

	kfree(hdlr);
}
EXPORT_SYMBOL(dtrace_invop_remove);

/*
 * Enable an INVOP-based probe, i.e. ensure that an INVOP trap is triggered at
 * the specified address.
 */
void dtrace_invop_enable(uint8_t *addr)
{
	text_poke(addr, ((unsigned char []){INVOP_TRAP_INSTR}), 1);
}
EXPORT_SYMBOL(dtrace_invop_enable);

/*
 * Disable an INVOP-based probe.
 */
void dtrace_invop_disable(uint8_t *addr, uint8_t opcode)
{
	text_poke(addr, ((unsigned char []){opcode}), 1);
}
EXPORT_SYMBOL(dtrace_invop_disable);
